from datetime import timedelta
import geopandas as gpd
import pandas as pd
import numpy as np
from tqdm import tqdm
from pyproj import Geod

import trackintel as ti


def generate_tours(
    trips_inp,
    stps_w_locs=None,
    max_dist=100,
    min_trips_on_tour=2,
    max_time=timedelta(days=1),
    max_gap_size=0,
    geom_col="geom",
    print_progress=False,
):
    """
    Generate trackintel-tours from trips
    - Tours are defined as a collection of trips in a certain time frame that start and end at the same point
    - Nested tours are possible and will be regarded as two distinct tours

    Parameters
    ----------
    trips_inp : GeoDataFrame (as trackintel trips)
        The trips have to follow the standard definition for trips DataFrames

    stps_w_locs : GeoDataFrame (as trackintel staypoints, preprocessed to contain location IDs), default None
        The staypoints have to follow the standard definition for staypoints DataFrames. The location ID column
        is necessary to connect trips via locations to a tour. If None, trips will be connected based only on a
        distance threshold `max_dist`.
                
    max_dist: float, default 100 (meters)
        Maximum distance between the end point of one trip and the start point of the next trip on a tour.
        Note: If `max_gap_size > 0` (see below), a tour can contain gaps

    min_trips_on_tour: int, default 2
        Minimum number of trips to form a tour
        
    max_time: Timedelta, default 1 day
        Maximum time that a tour is allowed to take

    max_gap_size: int, default 0
        It is possible to allow gaps to occur on the tour, which might be useful to deal with missing data.
        For example, home-work, supermarket-home would still be detected as a tour when max_gap_size >= 1, although
        the work-supermarket trip is missing.
                
    gap_threshold : float, default 15 (minutes)
        Maximum allowed temporal gap size in minutes. If tracking data is missing for more than 
        `gap_threshold` minutes, then a new trip begins after the gap.

    print_progress : bool, default False
        If print_progress is True, the progress bar is displayed


    Returns
    -------
    trips: GeoDataFrame (as trackintel trips)
        Same as `trips_inp`, but with additional column `tour_id`
    
    tours: GeoDataFrame (as trackintel tours)
        The generated tours

    """
    # Two options: either the location IDs for staypoints on the trips are provided, or a maximum distance threshold
    # between end and start of trips is used
    if stps_w_locs is not None:
        assert (
            "location_id" in stps_w_locs.columns
        ), "Staypoints with location ID is required, otherwise tours are generated wo location from maximum distance"
        print("Using locations to connect trips to tours")
    else:
        print("Locations not provided (parameter stps_w_locs) - using distance threshold to connect trips")

    # rename geom column if necessary
    assert geom_col in trips_inp.columns, "Trips table must be a GeoDataFrame and requires a geomentry column"
    trips = trips_inp.copy()
    trips = trips.rename(columns={geom_col: "geom"})

    kwargs = {
        "max_dist": max_dist,
        "min_trips_on_tour": min_trips_on_tour,
        "max_gap_size": max_gap_size,
        "max_time": max_time,
        "stps_w_locs": stps_w_locs,
    }
    if print_progress:
        tqdm.pandas(desc="User trip generation")
        tours = (
            trips.groupby(["user_id"], group_keys=False, as_index=False)
            .progress_apply(_generate_tours_user, **kwargs)
            .reset_index(drop=True)
        )
    else:
        tours = (
            trips.groupby(["user_id"], group_keys=False, as_index=False)
            .apply(_generate_tours_user, **kwargs)
            .reset_index(drop=True)
        )

    # # index management TODO
    tours["id"] = np.arange(len(tours))
    tours.set_index("id", inplace=True)

    # # assign trip_id to tpls
    tour2trip_map = tours[["trips"]].to_dict()["trips"]
    ls = []
    for key, values in tour2trip_map.items():
        for value in values:
            ls.append([value, key])
    temp = pd.DataFrame(ls, columns=[trips.index.name, "tour_id"]).set_index(trips.index.name)
    trips = trips.join(temp, how="left")

    # TODO: assign tour id to trips

    # TODO cleanup

    ## dtype consistency
    # trips id (generated by this function) should be int64
    tours.index = tours.index.astype("int64")
    # trips["tour_id"] = trips["tour_id"].astype("Int64")

    return trips, tours


def _generate_tours_user(
    user_trip_df, stps_w_locs=None, max_dist=100, min_trips_on_tour=2, max_gap_size=0, max_time=timedelta(days=1)
):
    assert min_trips_on_tour >= 2, "Tour must consist of at least 2 trips!"
    user_id = user_trip_df["user_id"].unique()
    assert len(user_id) == 1
    user_id = user_id[0]

    # sort by time
    user_trip_df = user_trip_df.sort_values(by=["started_at"])

    # save only the trip id (row.name) in the start candidates
    start_candidates = []

    # collect tours
    tours = []
    # Iterate over trips
    for i, row in user_trip_df.iterrows():
        trip_id = row.name  # trip id
        end_time = row["finished_at"]
        # print()
        # print("current point:", trip_id, start_point, end_point)
        # print("current candidates", start_candidates)

        # check if there is a gap between last and this trip
        if len(start_candidates) > 0:
            # compare end of last to start of new
            if stps_w_locs is not None:
                end_start_at_same_loc = _check_same_loc(
                    user_trip_df.loc[start_candidates[-1], "destination_staypoint_id"],  # dest. stp of previous trip
                    row["origin_staypoint_id"],  # start stp of current trip
                    stps_w_locs,
                )
            else:
                # check distance between point 1: end point of previous trip, point 2: start of current trip
                end_start_at_same_loc = _check_max_dist(
                    user_trip_df.loc[start_candidates[-1], "geom"][1], row["geom"][0], max_dist
                )

            # if the current trip does not start at the end of the previous trip, there is a gap
            if not end_start_at_same_loc:
                # option 1: no gaps allowed - start search again
                if max_gap_size == 0:
                    start_candidates = [row.name]
                    continue
                # option 2: gaps allowed - search further
                else:
                    start_candidates.append(np.nan)

        # Add this point as a candidate
        start_candidates.append(row.name)

        # Check if tour would be long enough
        if len(start_candidates) < min_trips_on_tour:
            continue

        # Check whether endpoint would be an unkown activity
        if pd.isna(row["destination_staypoint_id"]):
            continue

        # keep a list of which candidates to remove (because of time frame)
        new_list_start = 0

        # check distance to all candidates (except the ones that are too close)
        for j, cand in enumerate(start_candidates[: -min_trips_on_tour + 1]):
            #             print("------", j, cand)
            # gap
            if np.isnan(cand):
                continue

            # check time difference - if time too long, we can remove the candidate
            cand_start_time = user_trip_df.loc[cand, "started_at"]
            # print("time diff", end_time - cand_start_time)
            if end_time - cand_start_time > max_time:
                new_list_start = j + 1
                # print("removed candidate because time too long", j + 1)
                continue

            # check whether the start-end candidate of a tour is an unkown activity
            if pd.isna(user_trip_df.loc[cand, "origin_staypoint_id"]):
                continue

            # TODO: compute length of triplegs and sum - must be larger than minthresh
            # check if endpoint of trip = start location of cand
            if stps_w_locs is not None:
                end_start_at_same_loc = _check_same_loc(
                    user_trip_df.loc[cand, "origin_staypoint_id"],  # start stp of first trip
                    row["destination_staypoint_id"],  # destination stp of current trip
                    stps_w_locs,
                )
            else:
                # check distance between point 1: end point of current trip, point 2: start of first trip on tour
                end_start_at_same_loc = _check_max_dist(row["geom"][1], user_trip_df.loc[cand, "geom"][0], max_dist)

            # print("Check distance to start", cand, end_point, cand_start_point, point_dist)
            if end_start_at_same_loc:
                # Tour found!
                # collect the trips on the tour in a list
                non_gap_trip_idxs = [c for c in start_candidates[j:] if ~np.isnan(c)]
                tour_candidate = user_trip_df[user_trip_df.index.isin(non_gap_trip_idxs)]
                tours.append(_create_tour_from_stack(tour_candidate, stps_w_locs, max_dist, max_time))

                nr_gaps = np.sum(np.isnan(np.array(start_candidates[j:])))

                if nr_gaps > max_gap_size:
                    # No tour found, too many gaps inbetween
                    continue
                # print("Tour found!", tour_candidate.head())
                # _visualize_tour(tour_candidate)  # TODO

                # remove trips that were on the tour
                start_candidates = start_candidates[:j]
                # remove gap if there is a gap in the end
                if np.isnan(start_candidates[-1]):
                    del start_candidates[-1]
                # do not consider the other trips - one trip cannot close two tours at a time anyway
                break

        # remove points because they are out of the time window
        start_candidates = start_candidates[new_list_start:]
        # print("afterwards: ", start_candidates)

    tours_df = pd.DataFrame(tours)
    return tours_df


def _visualize_tour(tour_table):
    import matplotlib.pyplot as plt

    plot_tour = []
    for i, row in tour_table.iterrows():
        plot_tour.append([row["geom"][0].x, row["geom"][0].y])
        plot_tour.append([row["geom"][1].x, row["geom"][1].y])
    plot_tour = np.array(plot_tour)
    print(plot_tour)
    plt.figure(figsize=(8, 2))
    plt.plot(plot_tour[:, 0], plot_tour[:, 1])
    plt.show()


def _check_same_loc(stp1, stp2, stps_w_locs):
    if pd.isna(stp1) or pd.isna(stp2):
        return False
    return stps_w_locs.loc[stp1, "location_id"] == stps_w_locs.loc[stp2, "location_id"]


def _check_max_dist(p1, p2, max_dist):
    """
    Check whether two points p1, p2 are less or equal than max_dist apart

    Parameters
    --------
    p1, p2: shapely Point objects
    max_dist: int

    Returns
    ------
    dist_below_thresh: bool
        indicating whether p1 and p2 are less than max_dist apart
    """
    geod = Geod(ellps="CPM")  # other guy used WGS84
    dist = geod.inv(p1.x, p1.y, p2.x, p2.y)[2]
    dist_below_thresh = dist <= max_dist
    return dist_below_thresh


def _create_tour_from_stack(temp_tour_stack, stps_w_locs, max_dist, max_time):
    """
    Aggregate information of tour elements in a structured dictionary.

    Parameters
    ----------
    temp_tour_stack : list
        list of dictionary like elements (either pandas series or python dictionary).
        Contains all trips that will be aggregated into a tour

    Returns
    -------
    tour_dict_entry: dictionary

    """
    # this function return and empty dict if no tripleg is in the stack
    first_trip = temp_tour_stack.iloc[0]
    last_trip = temp_tour_stack.iloc[-1]

    # get location ID if available:
    if stps_w_locs is not None:
        start_loc = stps_w_locs.loc[first_trip["origin_staypoint_id"], "location_id"]
        # double check whether start and end location are the same
        end_loc = stps_w_locs.loc[last_trip["destination_staypoint_id"], "location_id"]
        assert start_loc == end_loc
    else:
        # double check distance between start and end point
        assert _check_max_dist(last_trip["geom"][1], first_trip["geom"][0], max_dist)
        # set location to NaN since not available
        start_loc = pd.NA

    # all data has to be from the same user
    assert len(temp_tour_stack["user_id"].unique()) == 1

    # double check if tour requirements are fulfilled
    assert last_trip["finished_at"] - first_trip["started_at"] < max_time

    tour_dict_entry = {
        "user_id": first_trip["user_id"],
        "started_at": first_trip["started_at"],
        "finished_at": last_trip["finished_at"],
        "origin_staypoint_id": first_trip.name,
        "destination_staypoint_id": last_trip.name,
        "trips": list(temp_tour_stack.index),
        "origin_destination_location_id": start_loc,
        "journey": pd.NA,
    }

    return tour_dict_entry


if __name__ == "__main__":
    import os

    # create trips from geolife (based on positionfixes)
    pfs, _ = ti.io.dataset_reader.read_geolife(os.path.join("tests", "data", "geolife_long"))
    pfs, stps = pfs.as_positionfixes.generate_staypoints(
        method="sliding", dist_threshold=25, time_threshold=5, gap_threshold=1e6
    )
    stps = stps.as_staypoints.create_activity_flag(time_threshold=15)
    pfs, tpls = pfs.as_positionfixes.generate_triplegs(stps)

    # generate trips and a joint staypoint/triplegs dataframe
    stps, tpls, trips = ti.preprocessing.triplegs.generate_trips(stps, tpls, gap_threshold=15)
    stps, locs = stps.as_staypoints.generate_locations(method="dbscan", epsilon=100, num_samples=1)

    # trips = ti.io.file.read_trips_csv(os.path.join("tests", "data", "geolife_long", "trips.csv"), index_col="id")

    # trips_user = trips[trips["user_id"] == 1]
    trips, tours = generate_tours(trips, max_dist=30, max_gap_size=1)  # stps_w_locs=stps,
    print(tours)

    # Tests: with max dist 100 same results as with locations
